import React, { useState, useEffect, useRef } from 'react';
import { Plus, X, Minimize2, Maximize2, ChevronDown, ChevronRight, Upload, Download, Folder, Link, Trash2, Edit2, Palette, MoreVertical } from 'lucide-react';

const LynkrWeb = () => {
  const [tabs, setTabs] = useState([]);
  const [currentTab, setCurrentTab] = useState(null);
  const [urlInput, setUrlInput] = useState('');
  const [isMaximized, setIsMaximized] = useState(false);
  const [draggedBookmark, setDraggedBookmark] = useState(null);
  const [draggedGroup, setDraggedGroup] = useState(null);
  const [backgroundColor, setBackgroundColor] = useState('#212121');
  const [showAddGroupDialog, setShowAddGroupDialog] = useState(false);
  const [showAddBookmarkDialog, setShowAddBookmarkDialog] = useState(false);
  const [showAddTabDialog, setShowAddTabDialog] = useState(false);
  const [contextMenu, setContextMenu] = useState(null);
  const fileInputRef = useRef(null);

  // Initialize with default tab
  useEffect(() => {
    const defaultTab = {
      name: 'Default',
      tabColor: '#2A4D6A',
      groups: {}
    };
    setTabs([defaultTab]);
    setCurrentTab(defaultTab);
    
    // Load from localStorage
    loadFromStorage();
  }, []);

  // Auto-save
  useEffect(() => {
    if (tabs.length > 0) {
      saveToStorage();
    }
  }, [tabs, currentTab, backgroundColor]);

  const saveToStorage = () => {
    const data = {
      backgroundColor,
      currentTab: currentTab?.name,
      tabs: tabs.map(tab => ({
        name: tab.name,
        tabColor: tab.tabColor || '#2A4D6A',
        groups: Object.entries(tab.groups || {}).map(([name, group]) => ({
          name,
          headerColor: group.headerColor || '#2A2A2A',
          backgroundColor: group.backgroundColor || '#1A1A1A',
          isCollapsed: group.isCollapsed || false,
          order: group.order || 0,
          bookmarks: (group.bookmarks || []).map(b => ({
            title: b.title,
            url: b.url,
            thumbnailUrl: b.thumbnailUrl,
            dateAdded: b.dateAdded,
            backgroundColor: b.backgroundColor || '#252525'
          }))
        }))
      }))
    };
    localStorage.setItem('lynkr-data', JSON.stringify(data));
  };

  const loadFromStorage = () => {
    const saved = localStorage.getItem('lynkr-data');
    if (saved) {
      try {
        const data = JSON.parse(saved);
        if (data.backgroundColor) setBackgroundColor(data.backgroundColor);
        
        if (data.tabs && data.tabs.length > 0) {
          const loadedTabs = data.tabs.map(tabData => ({
            name: tabData.name,
            tabColor: tabData.tabColor || '#2A4D6A',
            groups: (tabData.groups || []).reduce((acc, group) => {
              acc[group.name] = {
                headerColor: group.headerColor || '#2A2A2A',
                backgroundColor: group.backgroundColor || '#1A1A1A',
                isCollapsed: group.isCollapsed || false,
                order: group.order || 0,
                bookmarks: group.bookmarks || []
              };
              return acc;
            }, {})
          }));
          
          setTabs(loadedTabs);
          const activeTab = loadedTabs.find(t => t.name === data.currentTab) || loadedTabs[0];
          setCurrentTab(activeTab);
        }
      } catch (e) {
        console.error('Failed to load data:', e);
      }
    }
  };

  const getFaviconUrl = (url) => {
    try {
      const domain = new URL(url).hostname;
      return `https://www.google.com/s2/favicons?domain=${domain}&sz=64`;
    } catch {
      return 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/></svg>';
    }
  };

  const getPageTitle = async (url) => {
    try {
      // In a real implementation, you'd fetch the page title
      // For now, extract domain name
      const domain = new URL(url).hostname.replace('www.', '');
      return domain.charAt(0).toUpperCase() + domain.slice(1);
    } catch {
      return 'Bookmark';
    }
  };

  const addBookmark = async () => {
    if (!urlInput.trim() || !currentTab) return;
    
    let url = urlInput.trim();
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      url = 'https://' + url;
    }

    const title = await getPageTitle(url);
    const thumbnailUrl = getFaviconUrl(url);
    
    // Add to first group or create default group
    const groupName = Object.keys(currentTab.groups)[0] || 'Bookmarks';
    
    setTabs(tabs.map(tab => {
      if (tab.name === currentTab.name) {
        const updatedGroups = { ...tab.groups };
        if (!updatedGroups[groupName]) {
          updatedGroups[groupName] = { bookmarks: [], isCollapsed: false, order: 0 };
        }
        updatedGroups[groupName].bookmarks = [
          ...updatedGroups[groupName].bookmarks,
          { title, url, thumbnailUrl, dateAdded: new Date().toISOString(), backgroundColor: '#252525' }
        ];
        return { ...tab, groups: updatedGroups };
      }
      return tab;
    }));
    
    setCurrentTab(prev => {
      const updatedGroups = { ...prev.groups };
      if (!updatedGroups[groupName]) {
        updatedGroups[groupName] = { bookmarks: [], isCollapsed: false, order: 0 };
      }
      updatedGroups[groupName].bookmarks = [
        ...updatedGroups[groupName].bookmarks,
        { title, url, thumbnailUrl, dateAdded: new Date().toISOString(), backgroundColor: '#252525' }
      ];
      return { ...prev, groups: updatedGroups };
    });
    
    setUrlInput('');
  };

  const addGroup = (groupName) => {
    if (!groupName.trim() || !currentTab) return;
    
    setTabs(tabs.map(tab => {
      if (tab.name === currentTab.name) {
        return {
          ...tab,
          groups: {
            ...tab.groups,
            [groupName]: {
              bookmarks: [],
              isCollapsed: false,
              order: Object.keys(tab.groups).length,
              headerColor: '#2A2A2A',
              backgroundColor: '#1A1A1A'
            }
          }
        };
      }
      return tab;
    }));
    
    setCurrentTab(prev => ({
      ...prev,
      groups: {
        ...prev.groups,
        [groupName]: {
          bookmarks: [],
          isCollapsed: false,
          order: Object.keys(prev.groups).length,
          headerColor: '#2A2A2A',
          backgroundColor: '#1A1A1A'
        }
      }
    }));
  };

  const deleteGroup = (groupName) => {
    if (!confirm(`Delete group "${groupName}" and all its bookmarks?`)) return;
    
    setTabs(tabs.map(tab => {
      if (tab.name === currentTab.name) {
        const newGroups = { ...tab.groups };
        delete newGroups[groupName];
        return { ...tab, groups: newGroups };
      }
      return tab;
    }));
    
    setCurrentTab(prev => {
      const newGroups = { ...prev.groups };
      delete newGroups[groupName];
      return { ...prev, groups: newGroups };
    });
  };

  const deleteBookmark = (groupName, bookmarkIndex) => {
    setTabs(tabs.map(tab => {
      if (tab.name === currentTab.name) {
        const updatedGroups = { ...tab.groups };
        updatedGroups[groupName].bookmarks = updatedGroups[groupName].bookmarks.filter((_, i) => i !== bookmarkIndex);
        return { ...tab, groups: updatedGroups };
      }
      return tab;
    }));
    
    setCurrentTab(prev => {
      const updatedGroups = { ...prev.groups };
      updatedGroups[groupName].bookmarks = updatedGroups[groupName].bookmarks.filter((_, i) => i !== bookmarkIndex);
      return { ...prev, groups: updatedGroups };
    });
  };

  const addTab = (tabName) => {
    if (!tabName.trim()) return;
    
    const newTab = {
      name: tabName,
      tabColor: '#2A4D6A',
      groups: {}
    };
    
    setTabs([...tabs, newTab]);
    setCurrentTab(newTab);
  };

  const deleteTab = (tabToDelete) => {
    if (!confirm(`Delete tab "${tabToDelete.name}"?`)) return;
    
    const newTabs = tabs.filter(t => t.name !== tabToDelete.name);
    setTabs(newTabs);
    
    if (currentTab.name === tabToDelete.name) {
      setCurrentTab(newTabs[0] || null);
    }
  };

  const exportTab = (tab) => {
    const data = {
      name: tab.name,
      tabColor: tab.tabColor,
      groups: Object.entries(tab.groups).map(([name, group]) => ({
        name,
        headerColor: group.headerColor,
        backgroundColor: group.backgroundColor,
        isCollapsed: group.isCollapsed,
        order: group.order,
        bookmarks: group.bookmarks
      }))
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${tab.name}.lynk`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const importTab = (event) => {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target.result);
        
        let tabName = data.name;
        let counter = 1;
        while (tabs.some(t => t.name === tabName)) {
          counter++;
          tabName = `${data.name} (${counter})`;
        }
        
        const newTab = {
          name: tabName,
          tabColor: data.tabColor || '#2A4D6A',
          groups: (data.groups || []).reduce((acc, group) => {
            acc[group.name] = {
              headerColor: group.headerColor || '#2A2A2A',
              backgroundColor: group.backgroundColor || '#1A1A1A',
              isCollapsed: group.isCollapsed || false,
              order: group.order || 0,
              bookmarks: group.bookmarks || []
            };
            return acc;
          }, {})
        };
        
        setTabs([...tabs, newTab]);
        setCurrentTab(newTab);
        alert(`Imported ${Object.keys(newTab.groups).length} groups!`);
      } catch (error) {
        alert('Error importing file: ' + error.message);
      }
    };
    reader.readAsText(file);
    event.target.value = '';
  };

  const toggleCollapse = (groupName) => {
    setTabs(tabs.map(tab => {
      if (tab.name === currentTab.name) {
        return {
          ...tab,
          groups: {
            ...tab.groups,
            [groupName]: {
              ...tab.groups[groupName],
              isCollapsed: !tab.groups[groupName].isCollapsed
            }
          }
        };
      }
      return tab;
    }));
    
    setCurrentTab(prev => ({
      ...prev,
      groups: {
        ...prev.groups,
        [groupName]: {
          ...prev.groups[groupName],
          isCollapsed: !prev.groups[groupName].isCollapsed
        }
      }
    }));
  };

  const GroupCard = ({ groupName, group }) => (
    <div className="mb-4">
      <div 
        className="rounded-t"
        style={{ backgroundColor: group.headerColor || '#2A2A2A' }}
      >
        <div className="flex items-center justify-between px-4 py-3 border-b border-gray-700">
          <button
            onClick={() => toggleCollapse(groupName)}
            className="flex items-center gap-2 text-white hover:bg-white/10 rounded px-2 py-1"
          >
            {group.isCollapsed ? <ChevronRight size={16} /> : <ChevronDown size={16} />}
            <span className="font-semibold">{groupName}</span>
            <span className="text-gray-400 text-sm">({group.bookmarks?.length || 0})</span>
          </button>
          <button
            onClick={(e) => {
              e.stopPropagation();
              setContextMenu({
                type: 'group',
                x: e.clientX,
                y: e.clientY,
                data: groupName
              });
            }}
            className="text-gray-400 hover:text-white p-1"
          >
            <MoreVertical size={16} />
          </button>
        </div>
      </div>
      
      {!group.isCollapsed && (
        <div 
          className="p-5 rounded-b"
          style={{ backgroundColor: group.backgroundColor || '#1A1A1A' }}
        >
          {group.bookmarks?.map((bookmark, idx) => (
            <div
              key={idx}
              className="flex items-center gap-4 p-4 mb-2 rounded cursor-pointer transition-colors"
              style={{ backgroundColor: bookmark.backgroundColor || '#252525' }}
              onDoubleClick={() => window.open(bookmark.url, '_blank')}
              onContextMenu={(e) => {
                e.preventDefault();
                setContextMenu({
                  type: 'bookmark',
                  x: e.clientX,
                  y: e.clientY,
                  data: { groupName, bookmarkIndex: idx }
                });
              }}
            >
              <img
                src={bookmark.thumbnailUrl}
                alt=""
                className="w-12 h-12 rounded"
                onError={(e) => e.target.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/></svg>'}
              />
              <div className="flex-1 min-w-0">
                <div className="font-semibold text-gray-200 truncate">{bookmark.title}</div>
                <div className="text-sm text-gray-400 truncate">{bookmark.url}</div>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );

  return (
    <div className={`${isMaximized ? 'fixed inset-0' : 'h-screen'} bg-gray-900 text-white flex flex-col`}>
      {/* Header */}
      <div className="bg-gray-900 border-b border-gray-800 flex items-center justify-between px-4 py-2">
        <div className="flex items-center gap-2">
          <Link className="text-blue-400" size={24} />
          <span className="font-bold text-lg">Lynkr</span>
        </div>
        <div className="flex gap-2">
          <button
            onClick={() => setIsMaximized(!isMaximized)}
            className="hover:bg-gray-700 p-2 rounded"
          >
            {isMaximized ? <Minimize2 size={16} /> : <Maximize2 size={16} />}
          </button>
        </div>
      </div>

      <div className="flex flex-1 overflow-hidden">
        {/* Sidebar */}
        <div className="w-56 bg-gray-950 border-r border-gray-800 flex flex-col">
          <div className="flex-1 overflow-y-auto p-3">
            {tabs.map((tab, idx) => (
              <button
                key={idx}
                onClick={() => setCurrentTab(tab)}
                onContextMenu={(e) => {
                  e.preventDefault();
                  setContextMenu({
                    type: 'tab',
                    x: e.clientX,
                    y: e.clientY,
                    data: tab
                  });
                }}
                className="w-full text-left px-4 py-3 rounded mb-1 transition-colors"
                style={{
                  backgroundColor: currentTab?.name === tab.name ? tab.tabColor : 'transparent',
                  color: currentTab?.name === tab.name ? 'white' : '#aaa'
                }}
              >
                {tab.name}
              </button>
            ))}
          </div>

          <div className="p-3 space-y-2">
            <div className="grid grid-cols-2 gap-2">
              <button
                onClick={() => fileInputRef.current?.click()}
                className="px-3 py-2 bg-gray-800 hover:bg-gray-700 rounded text-xs flex items-center justify-center gap-1"
              >
                <Upload size={14} /> Import
              </button>
              <button
                onClick={() => currentTab && exportTab(currentTab)}
                className="px-3 py-2 bg-gray-800 hover:bg-gray-700 rounded text-xs flex items-center justify-center gap-1"
              >
                <Download size={14} /> Export
              </button>
            </div>
            <button
              onClick={() => setShowAddTabDialog(true)}
              className="w-full px-4 py-3 bg-blue-600 hover:bg-blue-700 rounded font-semibold flex items-center justify-center gap-2"
            >
              <Plus size={18} /> New Tab
            </button>
          </div>
        </div>

        {/* Main Content */}
        <div className="flex-1 flex flex-col overflow-hidden">
          {/* Add Bookmark Bar */}
          <div className="bg-gray-950 border-b border-gray-800 p-4">
            <div className="flex gap-3">
              <input
                type="text"
                value={urlInput}
                onChange={(e) => setUrlInput(e.target.value)}
                onKeyDown={(e) => e.key === 'Enter' && addBookmark()}
                placeholder="Enter URL..."
                className="flex-1 bg-gray-800 border border-gray-700 rounded px-4 py-2 focus:outline-none focus:border-blue-500"
              />
              <button
                onClick={addBookmark}
                className="px-6 py-2 bg-blue-600 hover:bg-blue-700 rounded font-semibold"
              >
                Add Bookmark
              </button>
            </div>
          </div>

          {/* Bookmarks Area */}
          <div
            className="flex-1 overflow-y-auto p-6"
            style={{ backgroundColor }}
            onContextMenu={(e) => {
              e.preventDefault();
              setContextMenu({
                type: 'background',
                x: e.clientX,
                y: e.clientY
              });
            }}
          >
            {currentTab && Object.entries(currentTab.groups)
              .sort(([, a], [, b]) => (a.order || 0) - (b.order || 0))
              .map(([groupName, group]) => (
                <GroupCard key={groupName} groupName={groupName} group={group} />
              ))
            }
          </div>

          {/* Status Bar */}
          <div className="bg-gray-950 border-t border-gray-800 px-4 py-2 text-xs text-gray-500 flex justify-end">
            Lynkr Web v1.0.0
          </div>
        </div>
      </div>

      {/* Context Menu */}
      {contextMenu && (
        <>
          <div
            className="fixed inset-0 z-40"
            onClick={() => setContextMenu(null)}
          />
          <div
            className="fixed bg-gray-800 border border-gray-700 rounded shadow-lg z-50 py-1 min-w-[180px]"
            style={{ left: contextMenu.x, top: contextMenu.y }}
          >
            {contextMenu.type === 'group' && (
              <>
                <button
                  onClick={() => {
                    const name = prompt('New group name:');
                    if (name) addGroup(name);
                    setContextMenu(null);
                  }}
                  className="w-full text-left px-4 py-2 hover:bg-gray-700 flex items-center gap-2"
                >
                  <Plus size={14} /> Add Bookmark
                </button>
                <button
                  onClick={() => {
                    deleteGroup(contextMenu.data);
                    setContextMenu(null);
                  }}
                  className="w-full text-left px-4 py-2 hover:bg-red-900/50 text-red-400 flex items-center gap-2"
                >
                  <Trash2 size={14} /> Delete Group
                </button>
              </>
            )}
            
            {contextMenu.type === 'bookmark' && (
              <button
                onClick={() => {
                  deleteBookmark(contextMenu.data.groupName, contextMenu.data.bookmarkIndex);
                  setContextMenu(null);
                }}
                className="w-full text-left px-4 py-2 hover:bg-red-900/50 text-red-400 flex items-center gap-2"
              >
                <Trash2 size={14} /> Delete Bookmark
              </button>
            )}
            
            {contextMenu.type === 'background' && (
              <button
                onClick={() => {
                  const name = prompt('Group name:');
                  if (name) addGroup(name);
                  setContextMenu(null);
                }}
                className="w-full text-left px-4 py-2 hover:bg-gray-700 flex items-center gap-2"
              >
                <Folder size={14} /> Add New Group
              </button>
            )}
            
            {contextMenu.type === 'tab' && (
              <>
                <button
                  onClick={() => {
                    exportTab(contextMenu.data);
                    setContextMenu(null);
                  }}
                  className="w-full text-left px-4 py-2 hover:bg-gray-700 flex items-center gap-2"
                >
                  <Download size={14} /> Export Tab
                </button>
                <button
                  onClick={() => {
                    deleteTab(contextMenu.data);
                    setContextMenu(null);
                  }}
                  className="w-full text-left px-4 py-2 hover:bg-red-900/50 text-red-400 flex items-center gap-2"
                >
                  <Trash2 size={14} /> Delete Tab
                </button>
              </>
            )}
          </div>
        </>
      )}

      {/* Add Tab Dialog */}
      {showAddTabDialog && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-gray-800 rounded-lg p-6 w-96">
            <h3 className="text-xl font-bold mb-4">Add New Tab</h3>
            <inputhttps://github.com/TenakinVFX/TenakinVFX/tree/main
              type="text"
              placeholder="Tab name..."
              className="w-full bg-gray-700 border border-gray-600 rounded px-4 py-2 mb-4"
              onKeyDown={(e) => {
                if (e.key === 'Enter') {
                  addTab(e.target.value);
                  setShowAddTabDialog(false);
                }
              }}
              autoFocus
            />
            <div className="flex gap-2 justify-end">
              <button
                onClick={() => setShowAddTabDialog(false)}
                className="px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded"
              >
                Cancel
              </button>
              <button
                onClick={(e) => {
                  const input = e.target.parentElement.previousSibling;
                  addTab(input.value);
                  setShowAddTabDialog(false);
                }}
                className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded"
              >
                Add
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Hidden file input */}
      <input
        ref={fileInputRef}
        type="file"
        accept=".lynk,.json"
        onChange={importTab}
        className="hidden"
      />
    </div>
  );
};

export default LynkrWeb;
